/*
 * FaultySensorDetection.cc
 *
 *  This is based on exercise 2.1 from "Probabilistic Robotics" by Fox, Thrun,
 *  and Burgard.
 *
 *  Copyright (c) 2015, Norman Alan Oursland
 *  All rights reserved.
 */

#include "cognitoware/math/data/Vector.h"
#include "cognitoware/math/probability/BayesDistribution.h"
#include "cognitoware/math/probability/ConditionalMap.h"
#include "cognitoware/math/probability/discrete/DistributionValueMap.h"
#include "cognitoware/math/probability/RandomDistribution.h"
#include "cognitoware/math/probability/RangedUniform.h"
#include "gtest/gtest.h"

#include <iostream>
#include <memory>
#include <random>
#include <utility>

using ::cognitoware::math::data::Vector;
using ::cognitoware::math::probability::BayesDistribution;
using ::cognitoware::math::probability::ConditionalMap;
using ::cognitoware::math::probability::RandomConditional;
using ::cognitoware::math::probability::RandomDistribution;
using ::cognitoware::math::probability::RangedUniform;
using ::cognitoware::math::probability::discrete::DistributionValueMap;
//using ::cognitoware::math::probability::BayesianInference;

namespace examples {

// This single-element vector represents a value read from a sensor.
DEFINE_VECTOR1(SensorReading);

// The possible operational states of a sensor.
enum class SensorState {
  Normal, Faulty
};

// A sensor simulation. The sensor is either operating normally or is faulty.
// Sensor readings can be observed and are generated by sampling from a
// random distribution. The operational state (normal/faulty) determines
// what distribution an observation is selected from.
class Sensor {
public:
  Sensor(SensorState state) :
      state_(state) {
  }
  SensorReading CreateObservation(std::default_random_engine* generator) {
    std::uniform_real_distribution<double> dist(0, 1);
    if (state_ == SensorState::Faulty) {
      return SensorReading(dist(*generator));
    } else {
      return SensorReading(3.0 * dist(*generator));
    }
  }
private:
  SensorState state_;
};

// A model of the simulated sensor. As a conditional probability distribution,
// it provides the probability (density) of observing a specific reading for
// a specific sensor operational state.
class SensorModel : public ConditionalMap<SensorReading, SensorState> {
public:
  SensorModel() {
    Set(SensorState::Normal,
        std::make_shared<RangedUniform<SensorReading>>(SensorReading(0.0),
            SensorReading(3.0)));
    Set(SensorState::Faulty,
        std::make_shared<RangedUniform<SensorReading>>(SensorReading(0.0),
            SensorReading(1.0)));
  }
};

TEST(FaultySensorDetection, main) {
  // Create and validate the sensor model.
  std::shared_ptr<const RandomConditional<SensorReading, SensorState>> sensorModel =
      std::make_shared<SensorModel>();
  EXPECT_EQ(1.0 / 3.0,
      sensorModel->ConditionalProbabilityOf(SensorReading(0.5),
          SensorState::Normal));
  EXPECT_EQ(1.0,
      sensorModel->ConditionalProbabilityOf(SensorReading(0.5),
          SensorState::Faulty));

  // Create a simulated faulty sensor.
  Sensor sensor(SensorState::Faulty);
  // Create and validate a prior belief that the sensor is probably in a normal
  // operational state.
  std::shared_ptr<const RandomDistribution<SensorState>> belief =
      std::make_shared<DistributionValueMap<SensorState>>(SensorState::Normal,
          0.99, SensorState::Faulty, 0.01);
  double lastNormal = belief->ProbabilityOf(SensorState::Normal);
  EXPECT_EQ(0.99, lastNormal);
  std::cout << lastNormal << std::endl;

  // Observe the sensor and use the sensor model to update the belief about
  // the sensor state.
  std::default_random_engine generator(0);
  for (int i = 0; i < 25; i++) {
    SensorReading observation = sensor.CreateObservation(&generator);
    belief = std::make_shared<BayesDistribution<SensorState, SensorReading>>(
        belief, sensorModel, observation);
    // std::cout << belief->ProbabilityOf(SensorState::Normal) << std::endl;
  }

}

}  // namespace examples
